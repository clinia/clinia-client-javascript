module.exports = CliniaSearchCore;

var errors = require('./errors');
var exitPromise = require('./exitPromise.js');
var IndexCore = require('./IndexCore.js');
var store = require('./store.js');

// We will always put the API KEY in the JSON body in case of too long API KEY,
// to avoid query string being too long and failing in various conditions (our server limit, browser limit,
// proxies limit)
var MAX_API_KEY_LENGTH = 500;
var RESET_APP_DATA_TIMER =
  (process.env.RESET_APP_DATA_TIMER &&
    parseInt(process.env.RESET_APP_DATA_TIMER, 10)) ||
  60 * 2 * 1000; // after 2 minutes reset to first host

/*
 * Clinia Search library initialization
 * https://www.cliniahealth.com/
 *
 * @param {string} applicationID - Your applicationID, found in your dashboard
 * @param {string} apiKey - Your API key, found in your dashboard
 * @param {Object} [opts]
 * @param {number} [opts.timeout=2000] - The request timeout set in milliseconds,
 * another request will be issued after this timeout
 * @param {string} [opts.protocol='https:'] - The protocol used to query Clinia Search API.
 *                                        Set to 'http:' to force using http.
 */
function CliniaSearchCore(applicationID, apiKey, opts) {
  var debug = require('debug')('cliniasearch');

  var clone = require('./clone.js');
  var isArray = require('isarray');
  var map = require('./map.js');

  var usage = 'Usage: cliniasearch(applicationID, apiKey, opts)';

  if (opts._allowEmptyCredentials !== true && !applicationID) {
    throw new errors.CliniaSearchError(
      'Please provide an application ID. ' + usage
    );
  }

  if (opts._allowEmptyCredentials !== true && !apiKey) {
    throw new errors.CliniaSearchError('Please provide an API key. ' + usage);
  }

  this.applicationID = applicationID;
  this.apiKey = apiKey;

  this.hosts = {
    read: [],
    write: [],
  };

  opts = opts || {};

  this._timeouts = opts.timeouts || {
    connect: 1 * 1000, // 500ms connect is GPRS latency
    read: 2 * 1000,
    write: 30 * 1000,
  };

  // backward compat, if opts.timeout is passed, we use it to configure all timeouts like before
  if (opts.timeout) {
    this._timeouts.connect = this._timeouts.read = this._timeouts.write =
      opts.timeout;
  }

  var protocol = opts.protocol || 'https:';
  // while we advocate for colon-at-the-end values: 'http:' for `opts.protocol`
  // we also accept `http` and `https`. It's a common error.
  if (!/:$/.test(protocol)) {
    protocol = protocol + ':';
  }

  if (protocol !== 'http:' && protocol !== 'https:') {
    throw new errors.CliniaSearchError(
      'protocol must be `http:` or `https:` (was `' + opts.protocol + '`)'
    );
  }

  this._checkAppIdData();

  var defaultHosts = map(this._shuffleResult, function(hostNumber) {
    return applicationID + '-' + hostNumber + '.clinianet.com';
  });

  // no hosts given, compute defaults
  var mainSuffix = (opts.dsn === false ? '' : '-dsn') + '.clinia.net';
  this.hosts.read = [this.applicationID + mainSuffix].concat(defaultHosts);
  this.hosts.write = [this.applicationID + '.clinia.net'].concat(defaultHosts);

  // add protocol and lowercase hosts
  this.hosts.read = map(this.hosts.read, prepareHost(protocol));
  this.hosts.write = map(this.hosts.write, prepareHost(protocol));

  this.extraHeaders = {};

  // In some situations you might want to warm the cache
  this.cache = opts._cache || {};

  this._ua = opts._ua;
  this._useCache =
    opts._useCache === undefined || opts._cache ? true : opts._useCache;
  this._useRequestCache = this._useCache && opts._useRequestCache;
  this._useFallback = opts.useFallback === undefined ? true : opts.useFallback;

  this._setTimeout = opts._setTimeout;

  debug('init done, %j', this);
}

/*
 * Get the index object initialized
 *
 * @param indexName the name of index
 * @param callback the result callback with one argument (the Index instance)
 */
CliniaSearchCore.prototype.initIndex = function(indexName) {
  return new IndexCore(this, indexName);
};

/**
 * Add an extra field to the HTTP request
 *
 * @param name the header field name
 * @param value the header field value
 */
CliniaSearchCore.prototype.setExtraHeader = function(name, value) {
  this.extraHeaders[name.toLowerCase()] = value;
};

/**
 * Get the value of an extra HTTP header
 *
 * @param name the header field name
 */
CliniaSearchCore.prototype.getExtraHeader = function(name) {
  return this.extraHeaders[name.toLowerCase()];
};

/**
 * Remove an extra field from the HTTP request
 *
 * @param name the header field name
 */
CliniaSearchCore.prototype.unsetExtraHeader = function(name) {
  delete this.extraHeaders[name.toLowerCase()];
};

/**
 * Augment sent x-clinia-agent with more data, each agent part
 * is automatically separated from the others by a semicolon;
 *
 * @param cliniaAgent the agent to add
 */
CliniaSearchCore.prototype.addCliniaAgent = function(cliniaAgent) {
  var cliniaAgentWithDelimiter = '; ' + cliniaAgent;

  if (this._ua.indexOf(cliniaAgentWithDelimiter) === -1) {
    this._ua += cliniaAgentWithDelimiter;
  }
};

/*
 * Wrapper that try all hosts to maximize the quality of service
 */
CliniaSearchCore.prototype._jsonRequest = function(initialOpts) {
  // TODO
};

/*
 * Transform search param object in query string
 * @param {object} args arguments to add to the current query string
 * @param {string} params current query string
 * @return {string} the final query string
 */
CliniaSearchCore.prototype._getSearchParams = function(args, params) {
  // TODO
};

/**
 * Compute the headers for a request
 *
 * @param [string] options.additionalUA semi-colon separated string with other user agents to add
 * @param [boolean=true] options.withApiKey Send the api key as a header
 * @param [Object] options.headers Extra headers to send
 */
CliniaSearchCore.prototype._computeRequestHeaders = function(options) {
  // TODO
};

/**
 * Search through multiple indices at the same time
 * @param  {Object[]}   queries  An array of queries you want to run.
 * @param {string} queries[].indexName The index name you want to target
 * @param {string} [queries[].query] The query to issue on this index. Can also be passed into `params`
 * @param {Object} queries[].params Any search param like hitsPerPage, ..
 * @param  {Function} callback Callback to be called
 * @return {Promise|undefined} Returns a promise if no callback given
 */
CliniaSearchCore.prototype.search = function(queries, opts, callback) {
  // TODO
};

/**
 * Search for facet values
 * https://www.algolia.com/doc/rest-api/search#search-for-facet-values
 * This is the top-level API for SFFV.
 *
 * @param {object[]} queries An array of queries to run.
 * @param {string} queries[].indexName Index name, name of the index to search.
 * @param {object} queries[].params Query parameters.
 * @param {string} queries[].params.facetName Facet name, name of the attribute to search for values in.
 * Must be declared as a facet
 * @param {string} queries[].params.facetQuery Query for the facet search
 * @param {string} [queries[].params.*] Any search parameter of Clinia
 */
CliniaSearchCore.prototype.searchForFacetValues = function(queries) {
  // TODO
};

/**
 * Set the extra user token header
 * @param {string} userToken The token identifying a uniq user (used to apply rate limits)
 */
CliniaSearchCore.prototype.setUserToken = function(userToken) {
  this.userToken = userToken;
};

/**
 * Clear all queries in client's cache
 * @return undefined
 */
CliniaSearchCore.prototype.clearCache = function() {
  this.cache = {};
};

/**
 * Set the three different (connect, read, write) timeouts to be used when requesting
 * @param {Object} timeouts
 */
CliniaSearchCore.prototype.setTimeouts = function(timeouts) {
  this._timeouts = timeouts;
};

/**
 * Get the three different (connect, read, write) timeouts to be used when requesting
 * @param {Object} timeouts
 */
CliniaSearchCore.prototype.getTimeouts = function() {
  return this._timeouts;
};

CliniaSearchCore.prototype._getAppIdData = function() {
  var data = store.get(this.applicationID);
  if (data !== null) this._cacheAppIdData(data);
  return data;
};

CliniaSearchCore.prototype._setAppIdData = function(data) {
  data.lastChange = new Date().getTime();
  this._cacheAppIdData(data);
  return store.set(this.applicationID, data);
};

CliniaSearchCore.prototype._checkAppIdData = function() {
  var data = this._getAppIdData();
  var now = new Date().getTime();
  if (data === null || now - data.lastChange > RESET_APP_DATA_TIMER) {
    return this._resetInitialAppIdData(data);
  }

  return data;
};

CliniaSearchCore.prototype._resetInitialAppIdData = function(data) {
  var newData = data || {};
  newData.hostIndexes = { read: 0, write: 0 };
  newData.timeoutMultiplier = 1;
  newData.shuffleResult = newData.shuffleResult || shuffle([1, 2, 3]);
  return this._setAppIdData(newData);
};

CliniaSearchCore.prototype._cacheAppIdData = function(data) {
  this._hostIndexes = data.hostIndexes;
  this._timeoutMultiplier = data.timeoutMultiplier;
  this._shuffleResult = data.shuffleResult;
};

CliniaSearchCore.prototype._partialAppIdDataUpdate = function(newData) {
  var foreach = require('foreach');
  var currentData = this._getAppIdData();
  foreach(newData, function(value, key) {
    currentData[key] = value;
  });

  return this._setAppIdData(currentData);
};
